// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: news_categories.sql

package database

import (
	"context"
	"database/sql"
)

const createNewsCategory = `-- name: CreateNewsCategory :one
INSERT INTO news_categories (name)
VALUES ($1)
RETURNING id, name, created_at, updated_at
`

func (q *Queries) CreateNewsCategory(ctx context.Context, name string) (NewsCategory, error) {
	row := q.db.QueryRowContext(ctx, createNewsCategory, name)
	var i NewsCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteNewsCategory = `-- name: DeleteNewsCategory :exec
DELETE FROM news_categories
WHERE id = $1
`

func (q *Queries) DeleteNewsCategory(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteNewsCategory, id)
	return err
}

const getAllCategoriesWithNews = `-- name: GetAllCategoriesWithNews :many
SELECT 
    nc.id AS category_id,
    nc.name AS category_name,
    n.id AS news_id,
    n.title AS news_title,
    n.content AS news_content,
    n.created_at AS news_created_at,
    n.updated_at AS news_updated_at
FROM 
    news_categories nc
LEFT JOIN 
    news n ON nc.id = n.category_id
ORDER BY 
    nc.name, n.created_at DESC
`

type GetAllCategoriesWithNewsRow struct {
	CategoryID    int32
	CategoryName  string
	NewsID        sql.NullInt32
	NewsTitle     sql.NullString
	NewsContent   sql.NullString
	NewsCreatedAt sql.NullTime
	NewsUpdatedAt sql.NullTime
}

func (q *Queries) GetAllCategoriesWithNews(ctx context.Context) ([]GetAllCategoriesWithNewsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCategoriesWithNews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCategoriesWithNewsRow
	for rows.Next() {
		var i GetAllCategoriesWithNewsRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryName,
			&i.NewsID,
			&i.NewsTitle,
			&i.NewsContent,
			&i.NewsCreatedAt,
			&i.NewsUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryWithNews = `-- name: GetCategoryWithNews :one
SELECT 
    nc.id AS category_id,
    nc.name AS category_name,
    n.id AS news_id,
    n.title AS news_title,
    n.content AS news_content,
    n.created_at AS news_created_at,
    n.updated_at AS news_updated_at
FROM 
    news_categories nc
LEFT JOIN 
    news n ON nc.id = n.category_id
WHERE 
    nc.id = $1  -- Pass the category ID as a parameter
ORDER BY 
    n.created_at DESC
`

type GetCategoryWithNewsRow struct {
	CategoryID    int32
	CategoryName  string
	NewsID        sql.NullInt32
	NewsTitle     sql.NullString
	NewsContent   sql.NullString
	NewsCreatedAt sql.NullTime
	NewsUpdatedAt sql.NullTime
}

func (q *Queries) GetCategoryWithNews(ctx context.Context, id int32) (GetCategoryWithNewsRow, error) {
	row := q.db.QueryRowContext(ctx, getCategoryWithNews, id)
	var i GetCategoryWithNewsRow
	err := row.Scan(
		&i.CategoryID,
		&i.CategoryName,
		&i.NewsID,
		&i.NewsTitle,
		&i.NewsContent,
		&i.NewsCreatedAt,
		&i.NewsUpdatedAt,
	)
	return i, err
}

const getNewsCategory = `-- name: GetNewsCategory :one
SELECT id, name, created_at, updated_at
FROM news_categories
WHERE id = $1
`

func (q *Queries) GetNewsCategory(ctx context.Context, id int32) (NewsCategory, error) {
	row := q.db.QueryRowContext(ctx, getNewsCategory, id)
	var i NewsCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateNewsCategory = `-- name: UpdateNewsCategory :one
UPDATE news_categories
SET name = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2
RETURNING id, name, created_at, updated_at
`

type UpdateNewsCategoryParams struct {
	Name string
	ID   int32
}

func (q *Queries) UpdateNewsCategory(ctx context.Context, arg UpdateNewsCategoryParams) (NewsCategory, error) {
	row := q.db.QueryRowContext(ctx, updateNewsCategory, arg.Name, arg.ID)
	var i NewsCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
