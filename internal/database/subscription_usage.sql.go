// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: subscription_usage.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const decrementPlatformConnections = `-- name: DecrementPlatformConnections :exec
WITH ensure_record AS (
    INSERT INTO subscription_usage_daily (user_id, subscription_id, platforms_connected, usage_date)
    VALUES ($1, $2, 0, CURRENT_DATE)
    ON CONFLICT (user_id, usage_date) DO NOTHING
)
UPDATE subscription_usage_daily sud
SET platforms_connected = GREATEST(sud.platforms_connected - 1, 0)
WHERE sud.user_id = $1 AND sud.usage_date = CURRENT_DATE
`

type DecrementPlatformConnectionsParams struct {
	UserID         uuid.UUID
	SubscriptionID uuid.UUID
}

func (q *Queries) DecrementPlatformConnections(ctx context.Context, arg DecrementPlatformConnectionsParams) error {
	_, err := q.db.ExecContext(ctx, decrementPlatformConnections, arg.UserID, arg.SubscriptionID)
	return err
}

const getActivePlatformConnectionsCount = `-- name: GetActivePlatformConnectionsCount :one
SELECT COALESCE(platforms_connected, 0)
FROM subscription_usage_daily
WHERE user_id = $1 AND usage_date = CURRENT_DATE
`

func (q *Queries) GetActivePlatformConnectionsCount(ctx context.Context, userID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getActivePlatformConnectionsCount, userID)
	var platforms_connected int32
	err := row.Scan(&platforms_connected)
	return platforms_connected, err
}

const getAllSubscriptionsUsage = `-- name: GetAllSubscriptionsUsage :many
SELECT 
    subscription_id,
    SUM(streaming_minutes_used) as total_streaming_minutes,
    SUM(storage_used_bytes) as total_storage_bytes,
    COUNT(DISTINCT user_id) as total_users,
    MAX(platforms_connected) as max_concurrent_platforms
FROM subscription_usage_daily
WHERE usage_date BETWEEN $1 AND $2
GROUP BY subscription_id
`

type GetAllSubscriptionsUsageParams struct {
	UsageDate   time.Time
	UsageDate_2 time.Time
}

type GetAllSubscriptionsUsageRow struct {
	SubscriptionID         uuid.UUID
	TotalStreamingMinutes  int64
	TotalStorageBytes      int64
	TotalUsers             int64
	MaxConcurrentPlatforms interface{}
}

func (q *Queries) GetAllSubscriptionsUsage(ctx context.Context, arg GetAllSubscriptionsUsageParams) ([]GetAllSubscriptionsUsageRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSubscriptionsUsage, arg.UsageDate, arg.UsageDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubscriptionsUsageRow
	for rows.Next() {
		var i GetAllSubscriptionsUsageRow
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.TotalStreamingMinutes,
			&i.TotalStorageBytes,
			&i.TotalUsers,
			&i.MaxConcurrentPlatforms,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentUsageStats = `-- name: GetCurrentUsageStats :one
SELECT 
    streaming_minutes_used,
    storage_used_bytes,
    platforms_connected,
    created_at,
    updated_at
FROM subscription_usage_daily
WHERE user_id = $1 
    AND usage_date = CURRENT_DATE
`

type GetCurrentUsageStatsRow struct {
	StreamingMinutesUsed int32
	StorageUsedBytes     int64
	PlatformsConnected   int32
	CreatedAt            sql.NullTime
	UpdatedAt            sql.NullTime
}

func (q *Queries) GetCurrentUsageStats(ctx context.Context, userID uuid.UUID) (GetCurrentUsageStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentUsageStats, userID)
	var i GetCurrentUsageStatsRow
	err := row.Scan(
		&i.StreamingMinutesUsed,
		&i.StorageUsedBytes,
		&i.PlatformsConnected,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDailyStreamingUsage = `-- name: GetDailyStreamingUsage :one
SELECT COALESCE(streaming_minutes_used, 0)
FROM subscription_usage_daily
WHERE user_id = $1 AND usage_date = $2
`

type GetDailyStreamingUsageParams struct {
	UserID    uuid.UUID
	UsageDate time.Time
}

func (q *Queries) GetDailyStreamingUsage(ctx context.Context, arg GetDailyStreamingUsageParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getDailyStreamingUsage, arg.UserID, arg.UsageDate)
	var streaming_minutes_used int32
	err := row.Scan(&streaming_minutes_used)
	return streaming_minutes_used, err
}

const getStorageUsage = `-- name: GetStorageUsage :one
SELECT COALESCE(storage_used_bytes, 0)
FROM subscription_usage_daily
WHERE user_id = $1 AND usage_date = CURRENT_DATE
`

func (q *Queries) GetStorageUsage(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getStorageUsage, userID)
	var storage_used_bytes int64
	err := row.Scan(&storage_used_bytes)
	return storage_used_bytes, err
}

const getSubscriptionDailyUsage = `-- name: GetSubscriptionDailyUsage :many
SELECT 
    usage_date,
    SUM(streaming_minutes_used) as daily_streaming_minutes,
    SUM(storage_used_bytes) as daily_storage_bytes,
    COUNT(DISTINCT user_id) as active_users,
    SUM(platforms_connected) as total_platforms
FROM subscription_usage_daily
WHERE subscription_id = $1 
    AND usage_date BETWEEN $2 AND $3
GROUP BY usage_date
ORDER BY usage_date DESC
`

type GetSubscriptionDailyUsageParams struct {
	SubscriptionID uuid.UUID
	UsageDate      time.Time
	UsageDate_2    time.Time
}

type GetSubscriptionDailyUsageRow struct {
	UsageDate             time.Time
	DailyStreamingMinutes int64
	DailyStorageBytes     int64
	ActiveUsers           int64
	TotalPlatforms        int64
}

func (q *Queries) GetSubscriptionDailyUsage(ctx context.Context, arg GetSubscriptionDailyUsageParams) ([]GetSubscriptionDailyUsageRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubscriptionDailyUsage, arg.SubscriptionID, arg.UsageDate, arg.UsageDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionDailyUsageRow
	for rows.Next() {
		var i GetSubscriptionDailyUsageRow
		if err := rows.Scan(
			&i.UsageDate,
			&i.DailyStreamingMinutes,
			&i.DailyStorageBytes,
			&i.ActiveUsers,
			&i.TotalPlatforms,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionTotalUsage = `-- name: GetSubscriptionTotalUsage :one
SELECT 
    subscription_id,
    SUM(streaming_minutes_used) as total_streaming_minutes,
    SUM(storage_used_bytes) as total_storage_bytes,
    COUNT(DISTINCT user_id) as total_users,
    MAX(platforms_connected) as max_concurrent_platforms
FROM subscription_usage_daily
WHERE subscription_id = $1 
    AND usage_date BETWEEN $2 AND $3
GROUP BY subscription_id
`

type GetSubscriptionTotalUsageParams struct {
	SubscriptionID uuid.UUID
	UsageDate      time.Time
	UsageDate_2    time.Time
}

type GetSubscriptionTotalUsageRow struct {
	SubscriptionID         uuid.UUID
	TotalStreamingMinutes  int64
	TotalStorageBytes      int64
	TotalUsers             int64
	MaxConcurrentPlatforms interface{}
}

func (q *Queries) GetSubscriptionTotalUsage(ctx context.Context, arg GetSubscriptionTotalUsageParams) (GetSubscriptionTotalUsageRow, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionTotalUsage, arg.SubscriptionID, arg.UsageDate, arg.UsageDate_2)
	var i GetSubscriptionTotalUsageRow
	err := row.Scan(
		&i.SubscriptionID,
		&i.TotalStreamingMinutes,
		&i.TotalStorageBytes,
		&i.TotalUsers,
		&i.MaxConcurrentPlatforms,
	)
	return i, err
}

const getTotalUserUsage = `-- name: GetTotalUserUsage :one
SELECT 
    SUM(streaming_minutes_used) as total_streaming_minutes,
    MAX(storage_used_bytes) as current_storage_bytes,
    MAX(platforms_connected) as max_platforms_connected
FROM subscription_usage_daily
WHERE user_id = $1 
    AND usage_date BETWEEN $2 AND $3
`

type GetTotalUserUsageParams struct {
	UserID      uuid.UUID
	UsageDate   time.Time
	UsageDate_2 time.Time
}

type GetTotalUserUsageRow struct {
	TotalStreamingMinutes int64
	CurrentStorageBytes   interface{}
	MaxPlatformsConnected interface{}
}

func (q *Queries) GetTotalUserUsage(ctx context.Context, arg GetTotalUserUsageParams) (GetTotalUserUsageRow, error) {
	row := q.db.QueryRowContext(ctx, getTotalUserUsage, arg.UserID, arg.UsageDate, arg.UsageDate_2)
	var i GetTotalUserUsageRow
	err := row.Scan(&i.TotalStreamingMinutes, &i.CurrentStorageBytes, &i.MaxPlatformsConnected)
	return i, err
}

const getUserUsageByDateRange = `-- name: GetUserUsageByDateRange :many
SELECT 
    usage_date,
    streaming_minutes_used,
    storage_used_bytes,
    platforms_connected
FROM subscription_usage_daily
WHERE user_id = $1 
    AND usage_date BETWEEN $2 AND $3
ORDER BY usage_date DESC
`

type GetUserUsageByDateRangeParams struct {
	UserID      uuid.UUID
	UsageDate   time.Time
	UsageDate_2 time.Time
}

type GetUserUsageByDateRangeRow struct {
	UsageDate            time.Time
	StreamingMinutesUsed int32
	StorageUsedBytes     int64
	PlatformsConnected   int32
}

func (q *Queries) GetUserUsageByDateRange(ctx context.Context, arg GetUserUsageByDateRangeParams) ([]GetUserUsageByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserUsageByDateRange, arg.UserID, arg.UsageDate, arg.UsageDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserUsageByDateRangeRow
	for rows.Next() {
		var i GetUserUsageByDateRangeRow
		if err := rows.Scan(
			&i.UsageDate,
			&i.StreamingMinutesUsed,
			&i.StorageUsedBytes,
			&i.PlatformsConnected,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementPlatformConnections = `-- name: IncrementPlatformConnections :exec
INSERT INTO subscription_usage_daily (user_id, subscription_id, platforms_connected, usage_date)
VALUES ($1, $2, 1, CURRENT_DATE)
ON CONFLICT (user_id, usage_date)
DO UPDATE SET platforms_connected = subscription_usage_daily.platforms_connected + 1
`

type IncrementPlatformConnectionsParams struct {
	UserID         uuid.UUID
	SubscriptionID uuid.UUID
}

func (q *Queries) IncrementPlatformConnections(ctx context.Context, arg IncrementPlatformConnectionsParams) error {
	_, err := q.db.ExecContext(ctx, incrementPlatformConnections, arg.UserID, arg.SubscriptionID)
	return err
}

const resetDailyUsage = `-- name: ResetDailyUsage :exec
INSERT INTO subscription_usage_daily (
    user_id,
    subscription_id,
    streaming_minutes_used,
    storage_used_bytes,
    platforms_connected,
    usage_date
)
SELECT 
    user_id,
    subscription_id,
    0, -- reset streaming minutes
    storage_used_bytes, -- maintain storage
    platforms_connected, -- maintain connections
    CURRENT_DATE
FROM subscription_usage_daily
WHERE usage_date = (CURRENT_DATE - INTERVAL '1 day')
ON CONFLICT (user_id, usage_date) DO NOTHING
`

func (q *Queries) ResetDailyUsage(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetDailyUsage)
	return err
}

const updateDailyStreamingUsage = `-- name: UpdateDailyStreamingUsage :exec
INSERT INTO subscription_usage_daily (user_id, subscription_id, streaming_minutes_used, usage_date)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, usage_date)
DO UPDATE SET streaming_minutes_used = subscription_usage_daily.streaming_minutes_used + EXCLUDED.streaming_minutes_used
`

type UpdateDailyStreamingUsageParams struct {
	UserID               uuid.UUID
	SubscriptionID       uuid.UUID
	StreamingMinutesUsed int32
	UsageDate            time.Time
}

func (q *Queries) UpdateDailyStreamingUsage(ctx context.Context, arg UpdateDailyStreamingUsageParams) error {
	_, err := q.db.ExecContext(ctx, updateDailyStreamingUsage,
		arg.UserID,
		arg.SubscriptionID,
		arg.StreamingMinutesUsed,
		arg.UsageDate,
	)
	return err
}

const updateStorageUsage = `-- name: UpdateStorageUsage :exec
INSERT INTO subscription_usage_daily (user_id, subscription_id, storage_used_bytes, usage_date)
VALUES ($1, $2, $3, CURRENT_DATE)
ON CONFLICT (user_id, usage_date)
DO UPDATE SET storage_used_bytes = EXCLUDED.storage_used_bytes
`

type UpdateStorageUsageParams struct {
	UserID           uuid.UUID
	SubscriptionID   uuid.UUID
	StorageUsedBytes int64
}

func (q *Queries) UpdateStorageUsage(ctx context.Context, arg UpdateStorageUsageParams) error {
	_, err := q.db.ExecContext(ctx, updateStorageUsage, arg.UserID, arg.SubscriptionID, arg.StorageUsedBytes)
	return err
}
