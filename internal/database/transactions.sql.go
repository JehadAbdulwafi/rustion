// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transactions.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    subscription_id, amount, currency,
    payment_method, error_message
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, subscription_id, amount, currency, status, payment_method, error_message, created_at, updated_at
`

type CreateTransactionParams struct {
	SubscriptionID uuid.UUID
	Amount         string
	Currency       string
	PaymentMethod  sql.NullString
	ErrorMessage   sql.NullString
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.SubscriptionID,
		arg.Amount,
		arg.Currency,
		arg.PaymentMethod,
		arg.ErrorMessage,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionBySubscriptionID = `-- name: GetTransactionBySubscriptionID :one
SELECT id, subscription_id, amount, currency, status, payment_method, error_message, created_at, updated_at FROM transactions WHERE subscription_id = $1
`

func (q *Queries) GetTransactionBySubscriptionID(ctx context.Context, subscriptionID uuid.UUID) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionBySubscriptionID, subscriptionID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT id, subscription_id, amount, currency, status, payment_method, error_message, created_at, updated_at FROM transactions
WHERE subscription_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetTransactions(ctx context.Context, subscriptionID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactions, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByStatus = `-- name: GetTransactionsByStatus :many
SELECT t.id, t.subscription_id, t.amount, t.currency, t.status, t.payment_method, t.error_message, t.created_at, t.updated_at, 
       s.user_id,
       s.plan_id,
       s.billing_cycle
FROM transactions t
JOIN subscriptions s ON t.subscription_id = s.id
WHERE t.status = $1
ORDER BY t.created_at DESC
LIMIT $2
`

type GetTransactionsByStatusParams struct {
	Status TransactionStatusEnum
	Limit  int32
}

type GetTransactionsByStatusRow struct {
	ID             uuid.UUID
	SubscriptionID uuid.UUID
	Amount         string
	Currency       string
	Status         TransactionStatusEnum
	PaymentMethod  sql.NullString
	ErrorMessage   sql.NullString
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	UserID         uuid.UUID
	PlanID         uuid.UUID
	BillingCycle   SubscriptionBillingCycleEnum
}

func (q *Queries) GetTransactionsByStatus(ctx context.Context, arg GetTransactionsByStatusParams) ([]GetTransactionsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByStatus, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionsByStatusRow
	for rows.Next() {
		var i GetTransactionsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.PlanID,
			&i.BillingCycle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTransactions = `-- name: GetUserTransactions :many
SELECT t.id, t.subscription_id, t.amount, t.currency, t.status, t.payment_method, t.error_message, t.created_at, t.updated_at
FROM transactions t
JOIN subscriptions s ON t.subscription_id = s.id
WHERE s.user_id = $1
ORDER BY t.created_at DESC
`

func (q *Queries) GetUserTransactions(ctx context.Context, userID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getUserTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE transactions
SET status = $2,
    error_message = CASE 
        WHEN $2 = 'failed' THEN $3
        ELSE error_message
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, subscription_id, amount, currency, status, payment_method, error_message, created_at, updated_at
`

type UpdateTransactionStatusParams struct {
	ID           uuid.UUID
	Status       TransactionStatusEnum
	ErrorMessage sql.NullString
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, updateTransactionStatus, arg.ID, arg.Status, arg.ErrorMessage)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
